##06-18-2012 Design Issue:

  #HOW TO IMPLEMENT GENERIC TYPE

##PROBLEM:
To allow for generic reference counted data structures, all OffBrand compatible
"classes" must contain a common struct or incomplete type as the first member of
the data object for that class (the private struct in the incomplete type
implementation). Ideally this common element would be a statically allocated
incomplete type, which cannot be achieved directly.

##PROPOSED SOLUTION(s):
A: Implement this base element as a struct type only. This allows for easy
   static allocation, but sacrifices data encapsulation entirely. Trades off
   data protection for ease of implementaion and use.

B: Implement this base element as an incomplete type only. This allows for
   complete data encapsulation, preventing direct manipulation of reference
   counts. Adds a large layer of complexity; the generic data type would now
   be a pointer to a pointer (the class must be dereferenced to allow access
   to the first data member of the class, a pointer to the base element).
   Complete encapsulation provided, but too much complexity added.

C: A hybrid of A&B. The base element is a struct (statically allocated) that
   contains a single pointer to an incomplete type encapsulating the reference
   counting information. Users could interact with this base element as they
   would with the base element in A, while being prevented from altering key
   data directly as in B. There is some added complexity that is added behind
   the scenes, and a small amount of data is left bare to the user (the pointer
   to the encapsulating incomplete type that is contained within the struct).

D: Similar to C, but instead of an enclosing struct a typedef is used to combat
   the "pointer to pointer" complexity. Besided that the same idea, an
   incomplete type is hidden from the user by typedefing a pointer to an
   instance of the incomplete type to a type that appears not to be a pointer.
   UPDATE: Typedef the type, but do not use it in the incomplete type code,
   instead use it as the generic reference only.

##PROGRESS/DECISION:
Solution C chosen for initial implementation. Will complete in following days.
(06-18-2012)

###Updated with new proposed solution, D. (06-19-2012)

Both solutions C and D aren't great. C takes extra memory (space for a pointer
must be allocated in addition to the actual reference data), and the D syntax
clumsy. A small two or three letter type name for the generic type would likely
help with the syntax, to make the type appear more "native". itm elm pt mech ref
any ne (06-19-2012)

Chose obj as generic type name. Pointers to compatible classes can be cast to
and from a pointer to an obj instance. A version of solution D (06-19-2012)

##STATUS:
Completed.

--------------------------------------------------------------------------------


06-19-2012 Design Speculation:

  CLASS REGISTRY

All compatible classes have a dealloc function predefined in created source
files that takes the name `dealloc[CLASSNAME]`. This function takes an obj *
as an argument, so that it can be called by the reference counting mechanism. It
might be useful to dynamically build a "class register" that keeps track of what
types are being used in the current program, allow for dynamic class checking in
program, and to prevent class methods from being called on wrong classes.

Likely a first step down the treacherous road to writing a complete OOP library
for C.

At this date the only conflict with methods would be in dealloc. This is managed
entirely by template code generated by the class creation script, and so that
specific instance of error does not merit implementation on its own.

UPDATE (06-20-2012):
Simple solution implemented that check so see if two obj have the same dealloc
function, if so said to be equal. Depends on each class having one unique
dealloc function, which is not a terrible assumption to make.

STATUS:
Registry still theoretical, basic protection scheme based on dealloc function
comparison implemented.

--------------------------------------------------------------------------------

###06-29-2012 Design Issue:

  #LOCKING MECHANISM

All Offbrand classes require a locking mechanism to guarantee threadsafety. To
ensure a uniform interface the locking mechanism will be uniform to all Offbrand
classes (and it helps to remove some of the threadsafe procedures from user
maintenance). This mechanism should retain the object on a successful lock, and
release it before a successful unlock.

##DESIGN SPECS:
Two different locking modes are desired: READ-ONLY and WRITE-ONLY. All methods
that access and obj as a const qualify for the READ-ONLY, which only locks the
data for long enough to increment an internal counter that monitors the number
of threads currently performing read only operations (there is no Offbrand
determined limit). The WRITE-ONLY lock completely locks the data so that only a
single thread may alter any of it. As soon as a thread initiates a WRITE-ONLY
lock on an obj no more threads may qualify for a READ-ONLY lock until the WRITE
has completed. Threads already reading finish their normal usage with the data
before a write occurs.

##SOLUTIONS:
A)
A single queue-like data structure would be ideal for the locking mechanism,
lock requests would be stored in the queue and be processed in order of
appearance. An additional mutex or two would be needed to protect the locking
mechanism data (mutex 1) and the actual object data (mutex 2). All locks would
interact with mutex 1 to alter locking mechanism data (add and remove from
queue), but only WRITE-ONLY locks would interact with mutex 2.

Condition variables can be used to monitor counts, where signals are sent every
time a count variable returns to zero. This trades read an write operations to
trade places (with additional work).

B)
SEE locking_mechanism.txt FOR MORE DETAILS ON THE INTERNALS OF THE LOCKING 
MECHANISM

##PROGRESS
Read more about locking/threads in the Linux Programming Interface to determine
what structures are available and how to best meet design specs. Perhaps look
into select() system call to notify when lock status changes.

The Pthreads API provides a signaling construct that can notify other threads
when a variable status changes.

07-03-2012: Code for locking mechanism largely writen. Issue with how to build
  still remains. New issue created to deal with build structure.

07-08-2012: Code for locking mechanism completed, needs testing. General
  structure needs to be considered for where to apply the locking scheme.
  Another new issue created below to deal with the questions.

07-12-2012: Locking to be applied internally, regardless of threaded
  implementaion or not. If non-threaded locking API calls will just return 0 and
  do nothing else.

07-21-2012: Locking to be applied externally, simplifying the build of the
  entire library and the usage of classes. Specifically the current API of the
  OBVector cannot be safely implemented as is with internal thread safety
  mechanisms.

##STATUS:
Compiled implementation. Testing to occur.

--------------------------------------------------------------------------------

07-03-2012 Build Design

#PROBLEM: 

Two Offbrand libraries should exist, one with threaded support (extra lib space
and runtime requirements) and one without. These two libraries need to be built
separately and will likely have separate Makefiles (or atleast separate make
headers). A system needs to be put in place for easy organization of threaded
and non-threaded libs. Most classes will just need to be compiled twice, once
with the offbrand_threaded.h lib macro and once without the macro.

##SOLUTIONS:

Dependent upon the solution to the Locking Application issue below.

###Simple:
If all locking is to be done externally, by explicit calls from the user, then
a single library can be complied without slowing non-threaded applications. A
slight memory overhead for all unused locking data would be required, but for
simplicities sake this may be the best course of action.

###Difficult:
If all locking is to be done internally within Offbrand classes then two
libraries should be compiled to eliminated performance and memory overheads for
non-threaded applications. Solution Pending....

###PROGRESS:
Study examples of Makefiles designed to build multiple versions of the same
library, such as one that can work on both Windows and Linux.

07-08-2012: Dependency on Lock Application discovered, simple solution outlined.
07-12-2012: Difficult solution used. Define a macro with gcc flag -D at library
  compile that indicates whether full threaded functionallity should be compiled
  in code. This is abstracted away from normal use in the offbrand_stdlib and 
  offbrand_threadlib files.

###STATUS:
Solution following the Difficult path chosen.

--------------------------------------------------------------------------------

07-08-2012 Lock Application

##PROBLEM:
There are two valid methods of lock application at this time:
A) Apply locks internally to all Offbrand classes. This simplifies the use of
   Offbrand library data structures in threaded environments, the all thread
   safety is removed from users responsibility. Depends heavily on the user to 
   apply the locking conventions to the internals of any new classes developed
   to maintain thread safety. User attempting to control thread safety 
   on Offbrand builtins will cause problems.
B) Apply locks externally to all Offbrand classes. This simplifies the build
   process and programming of new classes at the expense of placing all thread
   safety libraries in the hands of the user.
The issue is deciding which method to use, or to determine other methods that
have yet to be considered.

##PROGRESS:
07-09-2012
Method A chosen. Method A moves locking into internal methods so that they just
work in practice. Method B requires that programs keep track of when locks are
required and when they are not, when an unlock is needed, etc. The added 
bookeeping is not worth the small gains in simplicity.

##STATUS:
Decision made. Complete.
