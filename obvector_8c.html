<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>offbrand: src/classes/obvector.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">offbrand
   </div>
   <div id="projectbrief">A collection of generic, reference counted datastructures in C for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_018e9aafb459e6e1a4953404cb0c0b1d.html">classes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">obvector.c File Reference<div class="ingroups"><a class="el" href="group__obvector.html">obvector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>obvector Method Implementation  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="obvector_8h_source.html">../../include/obvector.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="obvector__private_8h_source.html">../../include/private/obvector_private.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1a6160a98d508290844e492e2e6434f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a1a6160a98d508290844e492e2e6434f3">obvector_new</a> (uint32_t initial_capacity)</td></tr>
<tr class="memdesc:a1a6160a98d508290844e492e2e6434f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, creates a new instance of obvector with a given initial capacity.  <a href="#a1a6160a98d508290844e492e2e6434f3">More...</a><br/></td></tr>
<tr class="separator:a1a6160a98d508290844e492e2e6434f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e00673bfc6f9abec405fbb19fef7e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a5e00673bfc6f9abec405fbb19fef7e09">obvector_copy</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *to_copy)</td></tr>
<tr class="memdesc:a5e00673bfc6f9abec405fbb19fef7e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor, creates a new obvector that is a copy of an instance of another obvector.  <a href="#a5e00673bfc6f9abec405fbb19fef7e09">More...</a><br/></td></tr>
<tr class="separator:a5e00673bfc6f9abec405fbb19fef7e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37ca6a984ac72de530ab5976529d22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a8e37ca6a984ac72de530ab5976529d22">obvector_length</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v)</td></tr>
<tr class="memdesc:a8e37ca6a984ac72de530ab5976529d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements encompassed within the obvector.  <a href="#a8e37ca6a984ac72de530ab5976529d22">More...</a><br/></td></tr>
<tr class="separator:a8e37ca6a984ac72de530ab5976529d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e07e513737e2624bb017c92cb7382f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a67e07e513737e2624bb017c92cb7382f">obvector_store_at_index</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *to_store, int64_t index)</td></tr>
<tr class="memdesc:a67e07e513737e2624bb017c92cb7382f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the obj at the associated index in a vector, overwriting previous obj stored at that index and resizing the vector as needed.  <a href="#a67e07e513737e2624bb017c92cb7382f">More...</a><br/></td></tr>
<tr class="separator:a67e07e513737e2624bb017c92cb7382f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142037802238d44cbcf049cc4836dad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a142037802238d44cbcf049cc4836dad9">obvector_obj_at_index</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, int64_t index)</td></tr>
<tr class="memdesc:a142037802238d44cbcf049cc4836dad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the Offbrand compatile class instance stored an index in an obvector.  <a href="#a142037802238d44cbcf049cc4836dad9">More...</a><br/></td></tr>
<tr class="separator:a142037802238d44cbcf049cc4836dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3ba3b5f25ef7de8bc4d33799e7615c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a1b3ba3b5f25ef7de8bc4d33799e7615c">obvector_concat</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *destination, <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *to_append)</td></tr>
<tr class="memdesc:a1b3ba3b5f25ef7de8bc4d33799e7615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the contents of on vector to the end of another, concatenating the two.  <a href="#a1b3ba3b5f25ef7de8bc4d33799e7615c">More...</a><br/></td></tr>
<tr class="separator:a1b3ba3b5f25ef7de8bc4d33799e7615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30db55461372f237aea58a846b444e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a0b30db55461372f237aea58a846b444e">obvector_find_obj</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *to_find)</td></tr>
<tr class="memdesc:a0b30db55461372f237aea58a846b444e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an instance of any Offbrand compatible class in an obvector using a comparision function.  <a href="#a0b30db55461372f237aea58a846b444e">More...</a><br/></td></tr>
<tr class="separator:a0b30db55461372f237aea58a846b444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4524f2b6c12eaab3a8c421febef3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#afc4524f2b6c12eaab3a8c421febef3e1">obvector_sort</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, int8_t order)</td></tr>
<tr class="memdesc:afc4524f2b6c12eaab3a8c421febef3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an obvector from least-to-greatest or greatest-to-least using the standard compare function.  <a href="#afc4524f2b6c12eaab3a8c421febef3e1">More...</a><br/></td></tr>
<tr class="separator:afc4524f2b6c12eaab3a8c421febef3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db31872e333b1ad483dd924ddd90283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a7db31872e333b1ad483dd924ddd90283">obvector_sort_with_funct</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, int8_t order, <a class="el" href="offbrand_8h.html#a92ffc23c043efcb2e3b815a5bd8b9e95">ob_compare_fptr</a> funct)</td></tr>
<tr class="memdesc:a7db31872e333b1ad483dd924ddd90283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an obvector from least-to-greatest or greatest-to-least using a specified comparision function.  <a href="#a7db31872e333b1ad483dd924ddd90283">More...</a><br/></td></tr>
<tr class="separator:a7db31872e333b1ad483dd924ddd90283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb3845511f9068fa5d1b0cb382d9ad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#aefb3845511f9068fa5d1b0cb382d9ad3">obvector_clear</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v)</td></tr>
<tr class="memdesc:aefb3845511f9068fa5d1b0cb382d9ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all objects from an obvector, leaving it empty.  <a href="#aefb3845511f9068fa5d1b0cb382d9ad3">More...</a><br/></td></tr>
<tr class="separator:aefb3845511f9068fa5d1b0cb382d9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274fae366fc511dd7b458be4e1bd1654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a274fae366fc511dd7b458be4e1bd1654">obvector_create_default</a> (uint32_t initial_capacity)</td></tr>
<tr class="memdesc:a274fae366fc511dd7b458be4e1bd1654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the default obvector.  <a href="#a274fae366fc511dd7b458be4e1bd1654">More...</a><br/></td></tr>
<tr class="separator:a274fae366fc511dd7b458be4e1bd1654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd2afd85ccd9659e5eb8ff3c6fcdeee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a1dd2afd85ccd9659e5eb8ff3c6fcdeee">obvector_resize</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, uint32_t index)</td></tr>
<tr class="memdesc:a1dd2afd85ccd9659e5eb8ff3c6fcdeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes a vector if the number of objects it contains is equal to its capacity by doubling the potential capacity of the vector.  <a href="#a1dd2afd85ccd9659e5eb8ff3c6fcdeee">More...</a><br/></td></tr>
<tr class="separator:a1dd2afd85ccd9659e5eb8ff3c6fcdeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00843cdb02be5851dbc8250a3d1d1538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a00843cdb02be5851dbc8250a3d1d1538">obvector_recursive_sort</a> (<a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> **to_sort, uint32_t size, int8_t order, <a class="el" href="offbrand_8h.html#a92ffc23c043efcb2e3b815a5bd8b9e95">ob_compare_fptr</a> funct)</td></tr>
<tr class="memdesc:a00843cdb02be5851dbc8250a3d1d1538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal merge sort implementation for an obvector.  <a href="#a00843cdb02be5851dbc8250a3d1d1538">More...</a><br/></td></tr>
<tr class="separator:a00843cdb02be5851dbc8250a3d1d1538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496b7011e587796f7f1bcb1dca52f6a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="offbrand_8h.html#abd1b2101c81bb1362ae9b4e964b58d3a">ob_hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a496b7011e587796f7f1bcb1dca52f6a9">obvector_hash</a> (const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *to_hash)</td></tr>
<tr class="memdesc:a496b7011e587796f7f1bcb1dca52f6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash function for obvector.  <a href="#a496b7011e587796f7f1bcb1dca52f6a9">More...</a><br/></td></tr>
<tr class="separator:a496b7011e587796f7f1bcb1dca52f6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0329f0ec871d97bc2880dc781f323d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#add0329f0ec871d97bc2880dc781f323d">obvector_compare</a> (const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *a, const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *b)</td></tr>
<tr class="memdesc:add0329f0ec871d97bc2880dc781f323d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two instances of obvector.  <a href="#add0329f0ec871d97bc2880dc781f323d">More...</a><br/></td></tr>
<tr class="separator:add0329f0ec871d97bc2880dc781f323d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd945c12ed7f0b2824853ea1bf2af51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a9cd945c12ed7f0b2824853ea1bf2af51">obvector_display</a> (const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *to_print)</td></tr>
<tr class="memdesc:a9cd945c12ed7f0b2824853ea1bf2af51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display function for an instance of OBString.  <a href="#a9cd945c12ed7f0b2824853ea1bf2af51">More...</a><br/></td></tr>
<tr class="separator:a9cd945c12ed7f0b2824853ea1bf2af51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa1dd027bc7ca8954cef2b5a3ea58ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a9fa1dd027bc7ca8954cef2b5a3ea58ad">obvector_destroy</a> (<a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *to_dealloc)</td></tr>
<tr class="memdesc:a9fa1dd027bc7ca8954cef2b5a3ea58ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for obvector.  <a href="#a9fa1dd027bc7ca8954cef2b5a3ea58ad">More...</a><br/></td></tr>
<tr class="separator:a9fa1dd027bc7ca8954cef2b5a3ea58ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3901753d7f0972bc5bc4b3f45abc5e97"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8c.html#a3901753d7f0972bc5bc4b3f45abc5e97">obvector_find_valid_precursor</a> (<a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> **array, uint32_t index)</td></tr>
<tr class="memdesc:a3901753d7f0972bc5bc4b3f45abc5e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches an array of obj for the first encountered non-NULL pointer, returning the index where this pointer is found.  <a href="#a3901753d7f0972bc5bc4b3f45abc5e97">More...</a><br/></td></tr>
<tr class="separator:a3901753d7f0972bc5bc4b3f45abc5e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>obvector Method Implementation </p>
<dl class="section author"><dt>Author</dt><dd>theck </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aefb3845511f9068fa5d1b0cb382d9ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all objects from an obvector, leaving it empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add0329f0ec871d97bc2880dc781f323d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t obvector_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two instances of obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A non-NULL obj pointer to type obvector </td></tr>
    <tr><td class="paramname">b</td><td>A non-NULL obj pointer to type obvector</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">OB_NOT_EQUAL</td><td>a does not equal b </td></tr>
    <tr><td class="paramname">OB_EQUAL_TO</td><td>a equals b </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b3ba3b5f25ef7de8bc4d33799e7615c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the contents of on vector to the end of another, concatenating the two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>obvector that will be extended with the contents of to_append </td></tr>
    <tr><td class="paramname">to_append</td><td>obvector whos contents will be added to the end of destination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e00673bfc6f9abec405fbb19fef7e09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a>* obvector_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>to_copy</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Constructor, creates a new obvector that is a copy of an instance of another obvector. </p>
<p>The new copy is a shallow copy, it references the same obj pointers rather that creating unique copies of each contained obj</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_copy</td><td>The obvector instance to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of obvector that is a shallow copy of to_copy </dd></dl>

</div>
</div>
<a class="anchor" id="a274fae366fc511dd7b458be4e1bd1654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a>* obvector_create_default </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial_capacity</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the default obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_capacity</td><td>Capacity of the vector to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new, partially initialized instance of obvector </dd></dl>

</div>
</div>
<a class="anchor" id="a9fa1dd027bc7ca8954cef2b5a3ea58ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>to_dealloc</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_dealloc</td><td>An obj pointer to an instance of obvector with reference count of 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call manually, release will call automatically when the instances reference count drops to 0! </dd></dl>

</div>
</div>
<a class="anchor" id="a9cd945c12ed7f0b2824853ea1bf2af51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_display </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>to_print</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display function for an instance of OBString. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_print</td><td>A non-NULL obj pointer to type OBString </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b30db55461372f237aea58a846b444e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t obvector_find_obj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>to_find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for an instance of any Offbrand compatible class in an obvector using a comparision function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">to_find</td><td>A pointer to an instance of any Offbrand compatible class</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>to_find was not found in the obvector </td></tr>
    <tr><td class="paramname">1</td><td>to_find exists in the obvector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Specify NULL as the comparision function if the given obvector is known to contain instances of may different classes else the function will likely cause the program to be aborted </dd></dl>

</div>
</div>
<a class="anchor" id="a3901753d7f0972bc5bc4b3f45abc5e97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t obvector_find_valid_precursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> **&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches an array of obj for the first encountered non-NULL pointer, returning the index where this pointer is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array of pointers to instances of Offbrand compatible classes </td></tr>
    <tr><td class="paramname">index</td><td>Index from which to begin searching</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;UINT32_MAX</td><td>Index where a non-NULL pointer was found </td></tr>
    <tr><td class="paramname">UINT32_MAX</td><td>No non-NULL pointer was found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a496b7011e587796f7f1bcb1dca52f6a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="offbrand_8h.html#abd1b2101c81bb1362ae9b4e964b58d3a">ob_hash_t</a> obvector_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>to_hash</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash function for obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_hash</td><td>An obj pointer to an instance of obvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Key value (hash) for the given obj pointer to an obvector </dd></dl>

</div>
</div>
<a class="anchor" id="a8e37ca6a984ac72de530ab5976529d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t obvector_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of elements encompassed within the obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer corresponding to the length required to span all elements contained within the vector (including all NULL elements added by the user) </dd></dl>

</div>
</div>
<a class="anchor" id="a1a6160a98d508290844e492e2e6434f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a>* obvector_new </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial_capacity</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, creates a new instance of obvector with a given initial capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_capacity</td><td>Integer size for the vector capacity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created vector </dd></dl>

</div>
</div>
<a class="anchor" id="a142037802238d44cbcf049cc4836dad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a>* obvector_obj_at_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the Offbrand compatile class instance stored an index in an obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">index</td><td>An integer index that may be positive to index from the beginning of the vector or negative to index from the end of the vector (where index = -x associates to element at [size of v] - x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>When index is out of range of obvector </td></tr>
    <tr><td class="paramname">obj*</td><td>When index is in obvector range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call release on returned object unless the calling code already had a reference to the object before calling objAtVectorIndex that it wishes to relenquish </dd>
<dd>
Positive indexing can occur past vector length, negative indexing is limited to the range [-1, -(length of v)] </dd></dl>

</div>
</div>
<a class="anchor" id="a00843cdb02be5851dbc8250a3d1d1538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a>** obvector_recursive_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> **&#160;</td>
          <td class="paramname"><em>to_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a92ffc23c043efcb2e3b815a5bd8b9e95">ob_compare_fptr</a>&#160;</td>
          <td class="paramname"><em>funct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal merge sort implementation for an obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_sort</td><td>Primitive array of objects to be sorted </td></tr>
    <tr><td class="paramname">size</td><td>Size of to_sort </td></tr>
    <tr><td class="paramname">order</td><td>Accepts OB_LEAST_TO_GREATEST or OB_GREATEST_TO_LEAST as valid sorting orders </td></tr>
    <tr><td class="paramname">funct</td><td>A compare_fptr to a function that returns an int8_t when given two obj * arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sorted primitive array of objects (a new primitive array, not to_sort)</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>There is little to no parameter checking in this function, all sorting should use the publicly accessable function which calls this method internally. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dd2afd85ccd9659e5eb8ff3c6fcdeee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes a vector if the number of objects it contains is equal to its capacity by doubling the potential capacity of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">index</td><td>Index that vector must be resized to contain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc4524f2b6c12eaab3a8c421febef3e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts an obvector from least-to-greatest or greatest-to-least using the standard compare function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">order</td><td>Accepts OB_LEAST_TO_GREATEST or OB_GREATEST_TO_LEAST as valid sorting orders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If called on an obvector containing instances of multiple Offbrand classes the call will likely not sort members properly but will still likely reorder internal contents </dd>
<dd>
Sorting may appear to shrink vector as NULL values interspersed with valid objects will be consolidated and removed </dd></dl>

</div>
</div>
<a class="anchor" id="a7db31872e333b1ad483dd924ddd90283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_sort_with_funct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a92ffc23c043efcb2e3b815a5bd8b9e95">ob_compare_fptr</a>&#160;</td>
          <td class="paramname"><em>funct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts an obvector from least-to-greatest or greatest-to-least using a specified comparision function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">order</td><td>Accepts OB_LEAST_TO_GREATEST or OB_GREATEST_TO_LEAST as valid sorting orders </td></tr>
    <tr><td class="paramname">funct</td><td>A compare_fptr to a function that returns an int8_t when given two obj * arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Sorting may appear to shrink vector as NULL values interspersed with valid objects will be consolidated and removed </dd></dl>

</div>
</div>
<a class="anchor" id="a67e07e513737e2624bb017c92cb7382f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_store_at_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the obj at the associated index in a vector, overwriting previous obj stored at that index and resizing the vector as needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">to_add</td><td>A pointer to any Offbrand compativle class instance </td></tr>
    <tr><td class="paramname">index</td><td>An integer index that may be positive to index from the beginning of the vector or negative to index from the end of the vector (where index = -x associates to element at [length of v] - x)</td></tr>
  </table>
  </dd>
</dl>
<p>Storing NULL at an index in the vector is equivalent to removing that object from the vector (if it only is found in that single vector positition). Storing NULL beyond vector length has no effect on vector length</p>
<dl class="section warning"><dt>Warning</dt><dd>Positive indexing can occur past vector length, negative indexing is limited to the range [-1, -(length of v)] </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 30 2013 15:56:45 for offbrand by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
