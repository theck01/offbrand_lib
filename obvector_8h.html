<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>offbrand: include/obvector.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">offbrand
   </div>
   <div id="projectbrief">A collection of generic, reference counted datastructures in C for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">obvector.h File Reference<div class="ingroups"><a class="el" href="group__obvector.html">obvector</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>obvector Public Interface  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="offbrand_8h_source.html">offbrand.h</a>&quot;</code><br/>
</div>
<p><a href="obvector_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4fb30b2b1f422732c66d45fb9bdd3a6c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structobvector__struct.html">obvector_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a></td></tr>
<tr class="separator:a4fb30b2b1f422732c66d45fb9bdd3a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1a6160a98d508290844e492e2e6434f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a1a6160a98d508290844e492e2e6434f3">obvector_new</a> (uint32_t initial_capacity)</td></tr>
<tr class="memdesc:a1a6160a98d508290844e492e2e6434f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, creates a new instance of obvector with a given initial capacity.  <a href="#a1a6160a98d508290844e492e2e6434f3">More...</a><br/></td></tr>
<tr class="separator:a1a6160a98d508290844e492e2e6434f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e00673bfc6f9abec405fbb19fef7e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a5e00673bfc6f9abec405fbb19fef7e09">obvector_copy</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *to_copy)</td></tr>
<tr class="memdesc:a5e00673bfc6f9abec405fbb19fef7e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor, creates a new obvector that is a copy of an instance of another obvector.  <a href="#a5e00673bfc6f9abec405fbb19fef7e09">More...</a><br/></td></tr>
<tr class="separator:a5e00673bfc6f9abec405fbb19fef7e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37ca6a984ac72de530ab5976529d22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a8e37ca6a984ac72de530ab5976529d22">obvector_length</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v)</td></tr>
<tr class="memdesc:a8e37ca6a984ac72de530ab5976529d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements encompassed within the obvector.  <a href="#a8e37ca6a984ac72de530ab5976529d22">More...</a><br/></td></tr>
<tr class="separator:a8e37ca6a984ac72de530ab5976529d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfdb89c4e5ff45e414814cfc25bd288"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#aabfdb89c4e5ff45e414814cfc25bd288">obvector_store_at_index</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *to_add, int64_t index)</td></tr>
<tr class="memdesc:aabfdb89c4e5ff45e414814cfc25bd288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the obj at the associated index in a vector, overwriting previous obj stored at that index and resizing the vector as needed.  <a href="#aabfdb89c4e5ff45e414814cfc25bd288">More...</a><br/></td></tr>
<tr class="separator:aabfdb89c4e5ff45e414814cfc25bd288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142037802238d44cbcf049cc4836dad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a142037802238d44cbcf049cc4836dad9">obvector_obj_at_index</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, int64_t index)</td></tr>
<tr class="memdesc:a142037802238d44cbcf049cc4836dad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the Offbrand compatile class instance stored an index in an obvector.  <a href="#a142037802238d44cbcf049cc4836dad9">More...</a><br/></td></tr>
<tr class="separator:a142037802238d44cbcf049cc4836dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3ba3b5f25ef7de8bc4d33799e7615c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a1b3ba3b5f25ef7de8bc4d33799e7615c">obvector_concat</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *destination, <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *to_append)</td></tr>
<tr class="memdesc:a1b3ba3b5f25ef7de8bc4d33799e7615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the contents of on vector to the end of another, concatenating the two.  <a href="#a1b3ba3b5f25ef7de8bc4d33799e7615c">More...</a><br/></td></tr>
<tr class="separator:a1b3ba3b5f25ef7de8bc4d33799e7615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b30db55461372f237aea58a846b444e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a0b30db55461372f237aea58a846b444e">obvector_find_obj</a> (const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *to_find)</td></tr>
<tr class="memdesc:a0b30db55461372f237aea58a846b444e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for an instance of any Offbrand compatible class in an obvector using a comparision function.  <a href="#a0b30db55461372f237aea58a846b444e">More...</a><br/></td></tr>
<tr class="separator:a0b30db55461372f237aea58a846b444e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4524f2b6c12eaab3a8c421febef3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#afc4524f2b6c12eaab3a8c421febef3e1">obvector_sort</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, int8_t order)</td></tr>
<tr class="memdesc:afc4524f2b6c12eaab3a8c421febef3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an obvector from least-to-greatest or greatest-to-least using the standard compare function.  <a href="#afc4524f2b6c12eaab3a8c421febef3e1">More...</a><br/></td></tr>
<tr class="separator:afc4524f2b6c12eaab3a8c421febef3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db31872e333b1ad483dd924ddd90283"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#a7db31872e333b1ad483dd924ddd90283">obvector_sort_with_funct</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v, int8_t order, <a class="el" href="offbrand_8h.html#a92ffc23c043efcb2e3b815a5bd8b9e95">ob_compare_fptr</a> funct)</td></tr>
<tr class="memdesc:a7db31872e333b1ad483dd924ddd90283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an obvector from least-to-greatest or greatest-to-least using a specified comparision function.  <a href="#a7db31872e333b1ad483dd924ddd90283">More...</a><br/></td></tr>
<tr class="separator:a7db31872e333b1ad483dd924ddd90283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb3845511f9068fa5d1b0cb382d9ad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="obvector_8h.html#aefb3845511f9068fa5d1b0cb382d9ad3">obvector_clear</a> (<a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *v)</td></tr>
<tr class="memdesc:aefb3845511f9068fa5d1b0cb382d9ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all objects from an obvector, leaving it empty.  <a href="#aefb3845511f9068fa5d1b0cb382d9ad3">More...</a><br/></td></tr>
<tr class="separator:aefb3845511f9068fa5d1b0cb382d9ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>obvector Public Interface </p>
<dl class="section author"><dt>Author</dt><dd>theck</dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4fb30b2b1f422732c66d45fb9bdd3a6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structobvector__struct.html">obvector_struct</a> <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Class type declaration </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aefb3845511f9068fa5d1b0cb382d9ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all objects from an obvector, leaving it empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b3ba3b5f25ef7de8bc4d33799e7615c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the contents of on vector to the end of another, concatenating the two. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>obvector that will be extended with the contents of to_append </td></tr>
    <tr><td class="paramname">to_append</td><td>obvector whos contents will be added to the end of destination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e00673bfc6f9abec405fbb19fef7e09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a>* obvector_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>to_copy</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Constructor, creates a new obvector that is a copy of an instance of another obvector. </p>
<p>The new copy is a shallow copy, it references the same obj pointers rather that creating unique copies of each contained obj</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_copy</td><td>The obvector instance to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of obvector that is a shallow copy of to_copy </dd></dl>

</div>
</div>
<a class="anchor" id="a0b30db55461372f237aea58a846b444e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t obvector_find_obj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>to_find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for an instance of any Offbrand compatible class in an obvector using a comparision function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">to_find</td><td>A pointer to an instance of any Offbrand compatible class</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>to_find was not found in the obvector </td></tr>
    <tr><td class="paramname">1</td><td>to_find exists in the obvector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Specify NULL as the comparision function if the given obvector is known to contain instances of may different classes else the function will likely cause the program to be aborted </dd></dl>

</div>
</div>
<a class="anchor" id="a8e37ca6a984ac72de530ab5976529d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t obvector_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of elements encompassed within the obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer corresponding to the length required to span all elements contained within the vector (including all NULL elements added by the user) </dd></dl>

</div>
</div>
<a class="anchor" id="a1a6160a98d508290844e492e2e6434f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a>* obvector_new </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial_capacity</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, creates a new instance of obvector with a given initial capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_capacity</td><td>Integer size for the vector capacity</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created vector </dd></dl>

</div>
</div>
<a class="anchor" id="a142037802238d44cbcf049cc4836dad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a>* obvector_obj_at_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the Offbrand compatile class instance stored an index in an obvector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">index</td><td>An integer index that may be positive to index from the beginning of the vector or negative to index from the end of the vector (where index = -x associates to element at [size of v] - x)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>When index is out of range of obvector </td></tr>
    <tr><td class="paramname">obj*</td><td>When index is in obvector range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call release on returned object unless the calling code already had a reference to the object before calling objAtVectorIndex that it wishes to relenquish </dd>
<dd>
Positive indexing can occur past vector length, negative indexing is limited to the range [-1, -(length of v)] </dd></dl>

</div>
</div>
<a class="anchor" id="afc4524f2b6c12eaab3a8c421febef3e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts an obvector from least-to-greatest or greatest-to-least using the standard compare function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">order</td><td>Accepts OB_LEAST_TO_GREATEST or OB_GREATEST_TO_LEAST as valid sorting orders</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If called on an obvector containing instances of multiple Offbrand classes the call will likely not sort members properly but will still likely reorder internal contents </dd>
<dd>
Sorting may appear to shrink vector as NULL values interspersed with valid objects will be consolidated and removed </dd></dl>

</div>
</div>
<a class="anchor" id="a7db31872e333b1ad483dd924ddd90283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_sort_with_funct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a92ffc23c043efcb2e3b815a5bd8b9e95">ob_compare_fptr</a>&#160;</td>
          <td class="paramname"><em>funct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts an obvector from least-to-greatest or greatest-to-least using a specified comparision function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">order</td><td>Accepts OB_LEAST_TO_GREATEST or OB_GREATEST_TO_LEAST as valid sorting orders </td></tr>
    <tr><td class="paramname">funct</td><td>A compare_fptr to a function that returns an int8_t when given two obj * arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Sorting may appear to shrink vector as NULL values interspersed with valid objects will be consolidated and removed </dd></dl>

</div>
</div>
<a class="anchor" id="aabfdb89c4e5ff45e414814cfc25bd288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void obvector_store_at_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="obvector_8h.html#a4fb30b2b1f422732c66d45fb9bdd3a6c">obvector</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="offbrand_8h.html#a14f6160080cff474965b973219856f8f">obj</a> *&#160;</td>
          <td class="paramname"><em>to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the obj at the associated index in a vector, overwriting previous obj stored at that index and resizing the vector as needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A pointer to an instance of obvector </td></tr>
    <tr><td class="paramname">to_add</td><td>A pointer to any Offbrand compativle class instance </td></tr>
    <tr><td class="paramname">index</td><td>An integer index that may be positive to index from the beginning of the vector or negative to index from the end of the vector (where index = -x associates to element at [length of v] - x)</td></tr>
  </table>
  </dd>
</dl>
<p>Storing NULL at an index in the vector is equivalent to removing that object from the vector (if it only is found in that single vector positition). Storing NULL beyond vector length has no effect on vector length</p>
<dl class="section warning"><dt>Warning</dt><dd>Positive indexing can occur past vector length, negative indexing is limited to the range [-1, -(length of v)] </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 30 2013 15:56:45 for offbrand by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
